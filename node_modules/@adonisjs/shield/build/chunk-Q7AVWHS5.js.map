{"version":3,"sources":["../src/errors.ts","../src/guards/csp/keywords.ts"],"sourcesContent":["/*\n * @adonisjs/shield\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/// <reference types=\"@adonisjs/session/session_middleware\" />\n\nimport type { I18n } from '@adonisjs/i18n'\nimport { Exception } from '@poppinss/utils'\nimport { HttpContext } from '@adonisjs/core/http'\n\nexport const E_BAD_CSRF_TOKEN = class InvalidCSRFToken extends Exception {\n  code = 'E_BAD_CSRF_TOKEN'\n  status = 403\n  message = 'Invalid or expired CSRF token'\n  identifier = 'errors.E_BAD_CSRF_TOKEN'\n\n  /**\n   * Returns the message to be sent in the HTTP response.\n   * Feel free to override this method and return a custom\n   * response.\n   */\n  getResponseMessage(error: this, ctx: HttpContext) {\n    if ('i18n' in ctx) {\n      return (ctx.i18n as I18n).t(error.identifier, {}, error.message)\n    }\n    return error.message\n  }\n\n  async handle(error: this, ctx: HttpContext) {\n    ctx.session.flashExcept(['_csrf', '_method', 'password', 'password_confirmation'])\n    ctx.session.flashErrors({\n      [error.code]: this.getResponseMessage(error, ctx),\n    })\n    ctx.response.redirect().back()\n  }\n}\n","/*\n * @adonisjs/shield\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { ContentSecurityPolicyOptions } from 'helmet-csp'\nimport type { ServerResponse, IncomingMessage } from 'node:http'\n\nimport type { ValueOf } from '../../types.js'\n\n/**\n * A collection of CSP keywords that are resolved to actual values\n * during an HTTP request.\n */\nclass CSPKeywords {\n  #keywordsResolvers: Record<string, (_: IncomingMessage, response: ServerResponse) => string> = {}\n\n  /**\n   * Register a custom CSP directive keyword and resolve\n   * it to a value during an HTTP request.\n   */\n  register(keyword: string, resolver: (_: IncomingMessage, response: ServerResponse) => string) {\n    this.#keywordsResolvers[keyword] = resolver\n    return this\n  }\n\n  /**\n   * Resolves keywords\n   */\n  resolve(\n    directiveValues: ValueOf<Exclude<ContentSecurityPolicyOptions['directives'], undefined>>\n  ): ValueOf<Exclude<ContentSecurityPolicyOptions['directives'], undefined>> {\n    if (Array.isArray(directiveValues)) {\n      const keywords = Object.keys(this.#keywordsResolvers)\n      keywords.forEach((keyword) => {\n        const keywordIndex = directiveValues.indexOf(keyword)\n        if (keywordIndex > -1) {\n          directiveValues[keywordIndex] = this.#keywordsResolvers[keyword]\n        }\n      })\n    }\n\n    return directiveValues\n  }\n}\n\nconst cspKeywords = new CSPKeywords()\nexport { cspKeywords }\n"],"mappings":";;;;;AAAA;AAAA;AAAA;AAAA;AAYA,SAAS,iBAAiB;AAGnB,IAAM,mBAAmB,MAAM,yBAAyB,UAAU;AAAA,EACvE,OAAO;AAAA,EACP,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOb,mBAAmB,OAAa,KAAkB;AAChD,QAAI,UAAU,KAAK;AACjB,aAAQ,IAAI,KAAc,EAAE,MAAM,YAAY,CAAC,GAAG,MAAM,OAAO;AAAA,IACjE;AACA,WAAO,MAAM;AAAA,EACf;AAAA,EAEA,MAAM,OAAO,OAAa,KAAkB;AAC1C,QAAI,QAAQ,YAAY,CAAC,SAAS,WAAW,YAAY,uBAAuB,CAAC;AACjF,QAAI,QAAQ,YAAY;AAAA,MACtB,CAAC,MAAM,IAAI,GAAG,KAAK,mBAAmB,OAAO,GAAG;AAAA,IAClD,CAAC;AACD,QAAI,SAAS,SAAS,EAAE,KAAK;AAAA,EAC/B;AACF;;;ACtBA,IAAM,cAAN,MAAkB;AAAA,EAChB,qBAA+F,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMhG,SAAS,SAAiB,UAAoE;AAC5F,SAAK,mBAAmB,OAAO,IAAI;AACnC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,QACE,iBACyE;AACzE,QAAI,MAAM,QAAQ,eAAe,GAAG;AAClC,YAAM,WAAW,OAAO,KAAK,KAAK,kBAAkB;AACpD,eAAS,QAAQ,CAAC,YAAY;AAC5B,cAAM,eAAe,gBAAgB,QAAQ,OAAO;AACpD,YAAI,eAAe,IAAI;AACrB,0BAAgB,YAAY,IAAI,KAAK,mBAAmB,OAAO;AAAA,QACjE;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AACF;AAEA,IAAM,cAAc,IAAI,YAAY;","names":[]}