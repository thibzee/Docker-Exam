{"version":3,"sources":["../../../src/plugins/edge.ts"],"sourcesContent":["/*\n * @adonisjs/session\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { PluginFn } from 'edge.js/types'\nimport debug from '../debug.js'\n\n/**\n * The edge plugin for AdonisJS Session adds tags to read\n * flash messages\n */\nexport const edgePluginSession: PluginFn<undefined> = (edge) => {\n  debug('registering session tags with edge')\n\n  edge.registerTag({\n    tagName: 'flashMessage',\n    seekable: true,\n    block: true,\n    compile(parser, buffer, token) {\n      const expression = parser.utils.transformAst(\n        parser.utils.generateAST(token.properties.jsArg, token.loc, token.filename),\n        token.filename,\n        parser\n      )\n\n      const key = parser.utils.stringify(expression)\n\n      /**\n       * Write an if statement\n       */\n      buffer.writeStatement(\n        `if (state.flashMessages.has(${key})) {`,\n        token.filename,\n        token.loc.start.line\n      )\n\n      /**\n       * Define a local variable\n       */\n      buffer.writeExpression(\n        `let $message = state.flashMessages.get(${key})`,\n        token.filename,\n        token.loc.start.line\n      )\n\n      /**\n       * Create a local variables scope and tell the parser about\n       * the existence of the \"message\" variable\n       */\n      parser.stack.defineScope()\n      parser.stack.defineVariable('$message')\n\n      /**\n       * Process component children using the parser\n       */\n      token.children.forEach((child) => {\n        parser.processToken(child, buffer)\n      })\n\n      /**\n       * Clear the scope of the local variables before we\n       * close the if statement\n       */\n      parser.stack.clearScope()\n\n      /**\n       * Close if statement\n       */\n      buffer.writeStatement(`}`, token.filename, token.loc.start.line)\n    },\n  })\n\n  edge.registerTag({\n    tagName: 'inputError',\n    seekable: true,\n    block: true,\n    compile(parser, buffer, token) {\n      const expression = parser.utils.transformAst(\n        parser.utils.generateAST(token.properties.jsArg, token.loc, token.filename),\n        token.filename,\n        parser\n      )\n\n      const key = parser.utils.stringify(expression)\n\n      /**\n       * Write an if statement\n       */\n      buffer.writeStatement(\n        `if (!!state.flashMessages.get('inputErrorsBag', {})[${key}]) {`,\n        token.filename,\n        token.loc.start.line\n      )\n\n      /**\n       * Define a local variable\n       */\n      buffer.writeExpression(\n        `let $messages = state.flashMessages.get('inputErrorsBag', {})[${key}]`,\n        token.filename,\n        token.loc.start.line\n      )\n\n      /**\n       * Create a local variables scope and tell the parser about\n       * the existence of the \"messages\" variable\n       */\n      parser.stack.defineScope()\n      parser.stack.defineVariable('$messages')\n\n      /**\n       * Process component children using the parser\n       */\n      token.children.forEach((child) => {\n        parser.processToken(child, buffer)\n      })\n\n      /**\n       * Clear the scope of the local variables before we\n       * close the if statement\n       */\n      parser.stack.clearScope()\n\n      /**\n       * Close if statement\n       */\n      buffer.writeStatement(`}`, token.filename, token.loc.start.line)\n    },\n  })\n\n  edge.registerTag({\n    tagName: 'error',\n    seekable: true,\n    block: true,\n    compile(parser, buffer, token) {\n      const expression = parser.utils.transformAst(\n        parser.utils.generateAST(token.properties.jsArg, token.loc, token.filename),\n        token.filename,\n        parser\n      )\n\n      const key = parser.utils.stringify(expression)\n\n      /**\n       * Write an if statement\n       */\n      buffer.writeStatement(\n        `if (state.flashMessages.has(['errorsBag', ${key}])) {`,\n        token.filename,\n        token.loc.start.line\n      )\n\n      /**\n       * Define a local variable\n       */\n      buffer.writeExpression(\n        `let $message = state.flashMessages.get(['errorsBag', ${key}])`,\n        token.filename,\n        token.loc.start.line\n      )\n\n      /**\n       * Create a local variables scope and tell the parser about\n       * the existence of the \"messages\" variable\n       */\n      parser.stack.defineScope()\n      parser.stack.defineVariable('$message')\n\n      /**\n       * Process component children using the parser\n       */\n      token.children.forEach((child) => {\n        parser.processToken(child, buffer)\n      })\n\n      /**\n       * Clear the scope of the local variables before we\n       * close the if statement\n       */\n      parser.stack.clearScope()\n\n      /**\n       * Close if statement\n       */\n      buffer.writeStatement(`}`, token.filename, token.loc.start.line)\n    },\n  })\n\n  edge.registerTag({\n    tagName: 'errors',\n    seekable: true,\n    block: true,\n    compile(parser, buffer, token) {\n      /**\n       * Write an if statement\n       */\n      buffer.writeStatement(\n        `if (state.flashMessages.has('errorsBag')) {`,\n        token.filename,\n        token.loc.start.line\n      )\n\n      /**\n       * Define a local variable\n       */\n      buffer.writeExpression(\n        `let $messages = state.flashMessages.get('errorsBag')`,\n        token.filename,\n        token.loc.start.line\n      )\n\n      /**\n       * Create a local variables scope and tell the parser about\n       * the existence of the \"messages\" variable\n       */\n      parser.stack.defineScope()\n      parser.stack.defineVariable('$messages')\n\n      /**\n       * Process component children using the parser\n       */\n      token.children.forEach((child) => {\n        parser.processToken(child, buffer)\n      })\n\n      /**\n       * Clear the scope of the local variables before we\n       * close the if statement\n       */\n      parser.stack.clearScope()\n\n      /**\n       * Close if statement\n       */\n      buffer.writeStatement(`}`, token.filename, token.loc.start.line)\n    },\n  })\n}\n"],"mappings":"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","names":[]}