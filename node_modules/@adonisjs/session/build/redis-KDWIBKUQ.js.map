{"version":3,"sources":["../src/stores/redis.ts"],"sourcesContent":["/**\n * @adonisjs/session\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport string from '@poppinss/utils/string'\nimport { MessageBuilder } from '@adonisjs/core/helpers'\nimport type { Connection } from '@adonisjs/redis/types'\n\nimport debug from '../debug.js'\nimport type { SessionStoreContract, SessionData } from '../types.js'\n\n/**\n * File store to read/write session to filesystem\n */\nexport class RedisStore implements SessionStoreContract {\n  #connection: Connection\n  #ttlSeconds: number\n\n  constructor(connection: Connection, age: string | number) {\n    this.#connection = connection\n    this.#ttlSeconds = string.seconds.parse(age)\n    debug('initiating redis store')\n  }\n\n  /**\n   * Returns file contents. A new file will be created if it's\n   * missing.\n   */\n  async read(sessionId: string): Promise<SessionData | null> {\n    debug('redis store: reading session data %s', sessionId)\n\n    const contents = await this.#connection.get(sessionId)\n    if (!contents) {\n      return null\n    }\n\n    /**\n     * Verify contents with the session id and return them as an object. The verify\n     * method can fail when the contents is not JSON>\n     */\n    try {\n      return new MessageBuilder().verify<SessionData>(contents, sessionId)\n    } catch {\n      return null\n    }\n  }\n\n  /**\n   * Write session values to a file\n   */\n  async write(sessionId: string, values: Object): Promise<void> {\n    debug('redis store: writing session data %s, %O', sessionId, values)\n\n    const message = new MessageBuilder().build(values, undefined, sessionId)\n    await this.#connection.setex(sessionId, this.#ttlSeconds, message)\n  }\n\n  /**\n   * Cleanup session file by removing it\n   */\n  async destroy(sessionId: string): Promise<void> {\n    debug('redis store: destroying session data %s', sessionId)\n    await this.#connection.del(sessionId)\n  }\n\n  /**\n   * Updates the value expiry\n   */\n  async touch(sessionId: string): Promise<void> {\n    debug('redis store: touching session data %s', sessionId)\n    await this.#connection.expire(sessionId, this.#ttlSeconds)\n  }\n}\n"],"mappings":";;;;;AASA,OAAO,YAAY;AACnB,SAAS,sBAAsB;AASxB,IAAM,aAAN,MAAiD;AAAA,EACtD;AAAA,EACA;AAAA,EAEA,YAAY,YAAwB,KAAsB;AACxD,SAAK,cAAc;AACnB,SAAK,cAAc,OAAO,QAAQ,MAAM,GAAG;AAC3C,kBAAM,wBAAwB;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,KAAK,WAAgD;AACzD,kBAAM,wCAAwC,SAAS;AAEvD,UAAM,WAAW,MAAM,KAAK,YAAY,IAAI,SAAS;AACrD,QAAI,CAAC,UAAU;AACb,aAAO;AAAA,IACT;AAMA,QAAI;AACF,aAAO,IAAI,eAAe,EAAE,OAAoB,UAAU,SAAS;AAAA,IACrE,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,WAAmB,QAA+B;AAC5D,kBAAM,4CAA4C,WAAW,MAAM;AAEnE,UAAM,UAAU,IAAI,eAAe,EAAE,MAAM,QAAQ,QAAW,SAAS;AACvE,UAAM,KAAK,YAAY,MAAM,WAAW,KAAK,aAAa,OAAO;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,WAAkC;AAC9C,kBAAM,2CAA2C,SAAS;AAC1D,UAAM,KAAK,YAAY,IAAI,SAAS;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,WAAkC;AAC5C,kBAAM,yCAAyC,SAAS;AACxD,UAAM,KAAK,YAAY,OAAO,WAAW,KAAK,WAAW;AAAA,EAC3D;AACF;","names":[]}