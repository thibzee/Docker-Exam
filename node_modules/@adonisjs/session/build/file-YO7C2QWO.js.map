{"version":3,"sources":["../src/stores/file.ts"],"sourcesContent":["/**\n * @adonisjs/session\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { Stats } from 'node:fs'\nimport { dirname, join } from 'node:path'\nimport string from '@poppinss/utils/string'\nimport { MessageBuilder } from '@adonisjs/core/helpers'\nimport { access, mkdir, readFile, rm, writeFile, utimes, stat } from 'node:fs/promises'\n\nimport debug from '../debug.js'\nimport type { FileStoreConfig, SessionData, SessionStoreContract } from '../types.js'\n\n/**\n * File store writes the session data on the file system as. Each session\n * id gets its own file.\n */\nexport class FileStore implements SessionStoreContract {\n  #config: FileStoreConfig\n  #age: string | number\n\n  constructor(config: FileStoreConfig, age: string | number) {\n    this.#config = config\n    this.#age = age\n    debug('initiating file store %O', this.#config)\n  }\n\n  /**\n   * Returns an absolute path to the session id file\n   */\n  #getFilePath(sessionId: string): string {\n    return join(this.#config.location, `${sessionId}.txt`)\n  }\n\n  /**\n   * Check if a file exists at a given path or not\n   */\n  async #pathExists(path: string) {\n    try {\n      await access(path)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Returns stats for a file and ignoring missing\n   * files.\n   */\n  async #stats(path: string): Promise<Stats | null> {\n    try {\n      const stats = await stat(path)\n      return stats\n    } catch {\n      return null\n    }\n  }\n\n  /**\n   * Output file with contents to the given path\n   */\n  async #outputFile(path: string, contents: string) {\n    const pathDirname = dirname(path)\n\n    const dirExists = await this.#pathExists(pathDirname)\n    if (!dirExists) {\n      await mkdir(pathDirname, { recursive: true })\n    }\n\n    await writeFile(path, contents, 'utf-8')\n  }\n\n  /**\n   * Reads the session data from the disk.\n   */\n  async read(sessionId: string): Promise<SessionData | null> {\n    const filePath = this.#getFilePath(sessionId)\n    debug('file store: reading session data %', sessionId)\n\n    /**\n     * Return null when no session id file exists in first\n     * place\n     */\n    const stats = await this.#stats(filePath)\n    if (!stats) {\n      return null\n    }\n\n    /**\n     * Check if the file has been expired and return null (if expired)\n     */\n    const sessionWillExpireAt = stats.mtimeMs + string.milliseconds.parse(this.#age)\n    if (Date.now() > sessionWillExpireAt) {\n      debug('file store: expired session data %s', sessionId)\n      return null\n    }\n\n    /**\n     * Reading the file contents if the file exists\n     */\n    let contents = await readFile(filePath, 'utf-8')\n    contents = contents.trim()\n    if (!contents) {\n      return null\n    }\n\n    /**\n     * Verify contents with the session id and return them as an object. The verify\n     * method can fail when the contents is not JSON>\n     */\n    try {\n      return new MessageBuilder().verify<SessionData>(contents, sessionId)\n    } catch {\n      return null\n    }\n  }\n\n  /**\n   * Writes the session data to the disk as a string\n   */\n  async write(sessionId: string, values: SessionData): Promise<void> {\n    debug('file store: writing session data %s: %O', sessionId, values)\n\n    const filePath = this.#getFilePath(sessionId)\n    const message = new MessageBuilder().build(values, undefined, sessionId)\n\n    await this.#outputFile(filePath, message)\n  }\n\n  /**\n   * Removes the session file from the disk\n   */\n  async destroy(sessionId: string): Promise<void> {\n    debug('file store: destroying session data %s', sessionId)\n    await rm(this.#getFilePath(sessionId), { force: true })\n  }\n\n  /**\n   * Updates the session expiry by rewriting it to the\n   * persistence store\n   */\n  async touch(sessionId: string): Promise<void> {\n    debug('file store: touching session data %s', sessionId)\n    await utimes(this.#getFilePath(sessionId), new Date(), new Date())\n  }\n}\n"],"mappings":";;;;;AAUA,SAAS,SAAS,YAAY;AAC9B,OAAO,YAAY;AACnB,SAAS,sBAAsB;AAC/B,SAAS,QAAQ,OAAO,UAAU,IAAI,WAAW,QAAQ,YAAY;AAS9D,IAAM,YAAN,MAAgD;AAAA,EACrD;AAAA,EACA;AAAA,EAEA,YAAY,QAAyB,KAAsB;AACzD,SAAK,UAAU;AACf,SAAK,OAAO;AACZ,kBAAM,4BAA4B,KAAK,OAAO;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,WAA2B;AACtC,WAAO,KAAK,KAAK,QAAQ,UAAU,GAAG,SAAS,MAAM;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAAc;AAC9B,QAAI;AACF,YAAM,OAAO,IAAI;AACjB,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,OAAO,MAAqC;AAChD,QAAI;AACF,YAAM,QAAQ,MAAM,KAAK,IAAI;AAC7B,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAAc,UAAkB;AAChD,UAAM,cAAc,QAAQ,IAAI;AAEhC,UAAM,YAAY,MAAM,KAAK,YAAY,WAAW;AACpD,QAAI,CAAC,WAAW;AACd,YAAM,MAAM,aAAa,EAAE,WAAW,KAAK,CAAC;AAAA,IAC9C;AAEA,UAAM,UAAU,MAAM,UAAU,OAAO;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK,WAAgD;AACzD,UAAM,WAAW,KAAK,aAAa,SAAS;AAC5C,kBAAM,sCAAsC,SAAS;AAMrD,UAAM,QAAQ,MAAM,KAAK,OAAO,QAAQ;AACxC,QAAI,CAAC,OAAO;AACV,aAAO;AAAA,IACT;AAKA,UAAM,sBAAsB,MAAM,UAAU,OAAO,aAAa,MAAM,KAAK,IAAI;AAC/E,QAAI,KAAK,IAAI,IAAI,qBAAqB;AACpC,oBAAM,uCAAuC,SAAS;AACtD,aAAO;AAAA,IACT;AAKA,QAAI,WAAW,MAAM,SAAS,UAAU,OAAO;AAC/C,eAAW,SAAS,KAAK;AACzB,QAAI,CAAC,UAAU;AACb,aAAO;AAAA,IACT;AAMA,QAAI;AACF,aAAO,IAAI,eAAe,EAAE,OAAoB,UAAU,SAAS;AAAA,IACrE,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,WAAmB,QAAoC;AACjE,kBAAM,2CAA2C,WAAW,MAAM;AAElE,UAAM,WAAW,KAAK,aAAa,SAAS;AAC5C,UAAM,UAAU,IAAI,eAAe,EAAE,MAAM,QAAQ,QAAW,SAAS;AAEvE,UAAM,KAAK,YAAY,UAAU,OAAO;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,WAAkC;AAC9C,kBAAM,0CAA0C,SAAS;AACzD,UAAM,GAAG,KAAK,aAAa,SAAS,GAAG,EAAE,OAAO,KAAK,CAAC;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,MAAM,WAAkC;AAC5C,kBAAM,wCAAwC,SAAS;AACvD,UAAM,OAAO,KAAK,aAAa,SAAS,GAAG,oBAAI,KAAK,GAAG,oBAAI,KAAK,CAAC;AAAA,EACnE;AACF;","names":[]}