/*
 * @adonisjs/vite
 *
 * (c) AdonisJS
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { existsSync, readFileSync } from 'node:fs';
import debug from './debug.js';
import { makeAttributes, uniqBy } from './utils.js';
/**
 * Vite class exposes the APIs to generate tags and URLs for
 * assets processed using vite.
 */
export class Vite {
    /**
     * We cache the manifest file content in production
     * to avoid reading the file multiple times
     */
    #manifestCache = null;
    /**
     * Configuration options
     */
    #options;
    constructor(options) {
        this.#options = options;
        this.#options.assetsUrl = (this.#options.assetsUrl || '/').replace(/\/$/, '');
        debug('vite config %O', this.#options);
    }
    /**
     * Checks if the application is running in hot mode
     */
    #isRunningHot() {
        return existsSync(this.#options.hotFile);
    }
    /**
     * Reads the file contents as JSON
     */
    #readFileAsJSON(filePath) {
        return JSON.parse(readFileSync(filePath, 'utf-8'));
    }
    /**
     * Returns the parsed hot file content
     */
    #readHotFile() {
        return this.#readFileAsJSON(this.#options.hotFile);
    }
    /**
     * Get the path to an asset when running in hot mode
     */
    #hotAsset(asset) {
        return this.#readHotFile().url + '/' + asset;
    }
    /**
     * Unwrap attributes from the user defined function or return
     * the attributes as it is
     */
    #unwrapAttributes(src, url, attributes) {
        if (typeof attributes === 'function') {
            return attributes({ src, url });
        }
        return attributes;
    }
    /**
     * Create a script tag for the given path
     */
    #makeScriptTag(src, url, attributes) {
        const customAttributes = this.#unwrapAttributes(src, url, this.#options.scriptAttributes);
        return this.#generateElement({
            tag: 'script',
            attributes: { type: 'module', ...customAttributes, ...attributes, src: url },
            children: [],
        });
    }
    /**
     * Create a style tag for the given path
     */
    #makeStyleTag(src, url, attributes) {
        const customAttributes = this.#unwrapAttributes(src, url, this.#options.styleAttributes);
        return this.#generateElement({
            tag: 'link',
            attributes: { rel: 'stylesheet', ...customAttributes, ...attributes, href: url },
        });
    }
    /**
     * Generate a HTML tag for the given asset
     */
    #generateTag(asset, attributes) {
        let url = '';
        if (this.#isRunningHot()) {
            url = this.#hotAsset(asset);
        }
        else {
            url = `${this.#options.assetsUrl}/${asset}`;
        }
        if (this.#isCssPath(asset)) {
            return this.#makeStyleTag(asset, url, attributes);
        }
        return this.#makeScriptTag(asset, url, attributes);
    }
    /**
     * Generates a JSON element with a custom toString implementation
     */
    #generateElement(element) {
        return {
            ...element,
            toString() {
                const attributes = `${makeAttributes(element.attributes)}`;
                if (element.tag === 'link') {
                    return `<${element.tag} ${attributes}/>`;
                }
                return `<${element.tag} ${attributes}>${element.children.join('\n')}</${element.tag}>`;
            },
        };
    }
    /**
     * Returns the script needed for the HMR working with Vite
     */
    #getViteHmrScript(attributes) {
        return this.#generateElement({
            tag: 'script',
            attributes: {
                type: 'module',
                src: this.#hotAsset('@vite/client'),
                ...attributes,
            },
            children: [],
        });
    }
    /**
     * Generate style and script tags for the given entrypoints
     * Also adds the @vite/client script
     */
    #generateEntryPointsTagsForHotMode(entryPoints, attributes) {
        const viteHmr = this.#getViteHmrScript(attributes);
        const tags = entryPoints.map((entrypoint) => this.#generateTag(entrypoint, attributes));
        return viteHmr ? [viteHmr].concat(tags) : tags;
    }
    /**
     * Generate style and script tags for the given entrypoints
     * using the manifest file
     */
    #generateEntryPointsTagsWithManifest(entryPoints, attributes) {
        const manifest = this.manifest();
        const tags = [];
        for (const entryPoint of entryPoints) {
            const chunk = this.#chunk(manifest, entryPoint);
            tags.push({
                path: chunk.file,
                tag: this.#generateTag(chunk.file, { ...attributes, integrity: chunk.integrity }),
            });
            for (const css of chunk.css || []) {
                tags.push({
                    path: css,
                    tag: this.#generateTag(css),
                });
            }
        }
        return uniqBy(tags, 'path')
            .sort((a) => (a.path.endsWith('.css') ? -1 : 1))
            .map((tag) => tag.tag);
    }
    /**
     * Get a chunk from the manifest file for a given file name
     */
    #chunk(manifest, fileName) {
        const chunk = manifest[fileName];
        if (!chunk) {
            throw new Error(`Cannot find "${fileName}" chunk in the manifest file`);
        }
        return chunk;
    }
    /**
     * Check if the given path is a CSS path
     */
    #isCssPath(path) {
        return path.match(/\.(css|less|sass|scss|styl|stylus|pcss|postcss)$/) !== null;
    }
    /**
     * Generate tags for the entry points
     */
    generateEntryPointsTags(entryPoints, attributes) {
        entryPoints = Array.isArray(entryPoints) ? entryPoints : [entryPoints];
        if (this.#isRunningHot()) {
            return this.#generateEntryPointsTagsForHotMode(entryPoints, attributes);
        }
        return this.#generateEntryPointsTagsWithManifest(entryPoints, attributes);
    }
    /**
     * Returns the dev server URL when running in hot
     * mode. Otherwise an empty string
     */
    devUrl() {
        if (this.#isRunningHot()) {
            return this.#readHotFile().url;
        }
        return '';
    }
    /**
     * Returns the dev server URL when running in hot
     * mode, otherwise returns the explicitly configured
     * "assets" URL
     */
    assetsUrl() {
        if (this.#isRunningHot()) {
            return this.#readHotFile().url;
        }
        return this.#options.assetsUrl;
    }
    /**
     * Returns path to a given asset file
     */
    assetPath(asset) {
        if (this.#isRunningHot()) {
            return this.#hotAsset(asset);
        }
        const chunk = this.#chunk(this.manifest(), asset);
        return `${this.#options.assetsUrl}/${chunk.file}`;
    }
    /**
     * Returns the manifest file contents
     *
     * @throws Will throw an exception when running in hot mode
     */
    manifest() {
        if (this.#isRunningHot()) {
            throw new Error('Cannot read the manifest file when running in hot mode');
        }
        if (!this.#manifestCache) {
            this.#manifestCache = this.#readFileAsJSON(this.#options.manifestFile);
        }
        return this.#manifestCache;
    }
    /**
     * Returns the script needed for the HMR working with React
     */
    getReactHmrScript(attributes) {
        if (!this.#isRunningHot()) {
            return null;
        }
        return this.#generateElement({
            tag: 'script',
            attributes: {
                type: 'module',
                ...attributes,
            },
            children: [
                '',
                `import RefreshRuntime from '${this.#hotAsset('@react-refresh')}'`,
                `RefreshRuntime.injectIntoGlobalHook(window)`,
                `window.$RefreshReg$ = () => {}`,
                `window.$RefreshSig$ = () => (type) => type`,
                `window.__vite_plugin_react_preamble_installed__ = true`,
                '',
            ],
        });
    }
}
